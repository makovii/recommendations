"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationsFactory = void 0;
const utils_1 = require("@graphql-tools/utils");
const neo4j_driver_1 = require("neo4j-driver");
const utils_2 = require("../../../utils/utils");
const is_concrete_entity_1 = require("../utils/is-concrete-entity");
const is_interface_entity_1 = require("../utils/is-interface-entity");
const is_union_entity_1 = require("../utils/is-union-entity");
const AggregateFactory_1 = require("./Operations/AggregateFactory");
const ConnectionFactory_1 = require("./Operations/ConnectionFactory");
const CreateFactory_1 = require("./Operations/CreateFactory");
const CustomCypherFactory_1 = require("./Operations/CustomCypherFactory");
const DeleteFactory_1 = require("./Operations/DeleteFactory");
const FulltextFactory_1 = require("./Operations/FulltextFactory");
const ReadFactory_1 = require("./Operations/ReadFactory");
const UpdateFactory_1 = require("./Operations/UpdateFactory");
const parse_operation_fields_1 = require("./parsers/parse-operation-fields");
const parse_selection_set_fields_1 = require("./parsers/parse-selection-set-fields");
class OperationsFactory {
    constructor(queryASTFactory) {
        this.filterFactory = queryASTFactory.filterFactory;
        this.fieldFactory = queryASTFactory.fieldFactory;
        this.sortAndPaginationFactory = queryASTFactory.sortAndPaginationFactory;
        this.authorizationFactory = queryASTFactory.authorizationFactory;
        this.createFactory = new CreateFactory_1.CreateFactory(queryASTFactory);
        this.updateFactory = new UpdateFactory_1.UpdateFactory(queryASTFactory);
        this.deleteFactory = new DeleteFactory_1.DeleteFactory(queryASTFactory);
        this.fulltextFactory = new FulltextFactory_1.FulltextFactory(queryASTFactory);
        this.aggregateFactory = new AggregateFactory_1.AggregateFactory(queryASTFactory);
        this.customCypherFactory = new CustomCypherFactory_1.CustomCypherFactory(queryASTFactory);
        this.connectionFactory = new ConnectionFactory_1.ConnectionFactory(queryASTFactory);
        this.readFactory = new ReadFactory_1.ReadFactory(queryASTFactory);
    }
    createTopLevelOperation({ entity, resolveTree, context, varName, reference, resolveAsUnwind = false, }) {
        // Handles deprecated top level fulltext
        if (entity &&
            (0, is_concrete_entity_1.isConcreteEntity)(entity) &&
            Boolean(entity.annotations.fulltext) &&
            context.fulltext &&
            context.resolveTree.args.phrase) {
            const indexName = context.fulltext.indexName ?? context.fulltext.name;
            if (indexName === undefined) {
                throw new Error("The name of the fulltext index should be defined using the indexName argument.");
            }
            (0, is_concrete_entity_1.assertIsConcreteEntity)(entity);
            return this.fulltextFactory.createFulltextOperation(entity, resolveTree, context);
        }
        const operationMatch = (0, parse_operation_fields_1.parseTopLevelOperationField)(resolveTree.name, context.schemaModel, entity);
        switch (operationMatch) {
            case "READ": {
                if (context.resolveTree.args.fulltext || context.resolveTree.args.phrase) {
                    (0, is_concrete_entity_1.assertIsConcreteEntity)(entity);
                    return this.fulltextFactory.createFulltextOperation(entity, resolveTree, context);
                }
                if (!entity) {
                    throw new Error("Entity is required for top level read operations");
                }
                return this.readFactory.createReadOperation({
                    entityOrRel: entity,
                    resolveTree,
                    context,
                    varName,
                    reference,
                });
            }
            case "CONNECTION": {
                if (!entity) {
                    throw new Error("Entity is required for top level connection read operations");
                }
                const topLevelConnectionResolveTree = this.connectionFactory.normalizeResolveTreeForTopLevelConnection(resolveTree);
                return this.connectionFactory.createConnectionOperationAST({
                    target: entity,
                    resolveTree: topLevelConnectionResolveTree,
                    context,
                });
            }
            case "AGGREGATE": {
                if (!entity || (0, is_union_entity_1.isUnionEntity)(entity)) {
                    throw new Error("Aggregate operations are not supported for Union types");
                }
                return this.aggregateFactory.createAggregationOperation(entity, resolveTree, context);
            }
            case "CREATE": {
                (0, is_concrete_entity_1.assertIsConcreteEntity)(entity);
                if (resolveAsUnwind) {
                    return this.createFactory.createUnwindCreateOperation(entity, resolveTree, context);
                }
                return this.createFactory.createCreateOperation(entity, resolveTree, context);
            }
            case "UPDATE": {
                (0, is_concrete_entity_1.assertIsConcreteEntity)(entity);
                return this.updateFactory.createUpdateOperation(entity, resolveTree, context);
            }
            case "DELETE": {
                (0, is_concrete_entity_1.assertIsConcreteEntity)(entity);
                return this.deleteFactory.createTopLevelDeleteOperation({
                    entity,
                    resolveTree,
                    context,
                    varName,
                });
            }
            case "CUSTOM_CYPHER": {
                return this.customCypherFactory.createTopLevelCustomCypherOperation({ entity, resolveTree, context });
            }
        }
    }
    /**
     *  Proxy methods to specialized operations factories.
     *  TODO: Refactor the following to use a generic dispatcher as done in createTopLevelOperation
     **/
    createReadOperation(arg) {
        return this.readFactory.createReadOperation(arg);
    }
    getFulltextSelection(entity, context) {
        return this.fulltextFactory.getFulltextSelection(entity, context);
    }
    createAggregationOperation(entityOrRel, resolveTree, context) {
        return this.aggregateFactory.createAggregationOperation(entityOrRel, resolveTree, context);
    }
    getConnectionOptions(entity, options) {
        return this.connectionFactory.getConnectionOptions(entity, options);
    }
    splitConnectionFields(rawFields) {
        return this.connectionFactory.splitConnectionFields(rawFields);
    }
    createConnectionOperationAST(arg) {
        return this.connectionFactory.createConnectionOperationAST(arg);
    }
    createCompositeConnectionOperationAST(arg) {
        return this.connectionFactory.createCompositeConnectionOperationAST(arg);
    }
    hydrateReadOperation(arg) {
        return this.readFactory.hydrateReadOperation(arg);
    }
    createCustomCypherOperation(arg) {
        return this.customCypherFactory.createCustomCypherOperation(arg);
    }
    /**
     * END of proxy methods
     **/
    hydrateOperation({ entity, operation, whereArgs, context, sortArgs, fieldsByTypeName, partialOf, }) {
        const concreteProjectionFields = { ...fieldsByTypeName[entity.name] };
        // Get the abstract types of the interface
        const entityInterfaces = entity.compositeEntities;
        const interfacesFields = (0, utils_2.filterTruthy)(entityInterfaces.map((i) => fieldsByTypeName[i.name]));
        const projectionFields = (0, utils_1.mergeDeep)([
            ...interfacesFields,
            concreteProjectionFields,
        ]);
        const fields = this.fieldFactory.createFields(entity, projectionFields, context);
        if (partialOf && (0, is_interface_entity_1.isInterfaceEntity)(partialOf)) {
            const filters = this.filterFactory.createInterfaceNodeFilters({
                entity: partialOf,
                targetEntity: entity,
                whereFields: whereArgs,
            });
            operation.addFilters(...filters);
        }
        else {
            const filters = this.filterFactory.createNodeFilters(entity, whereArgs);
            operation.addFilters(...filters);
        }
        const authFilters = this.authorizationFactory.getAuthFilters({
            entity,
            operations: ["READ"],
            attributes: this.getSelectedAttributes(entity, projectionFields),
            context,
        });
        operation.setFields(fields);
        operation.addAuthFilters(...authFilters);
        if (sortArgs) {
            const sortOptions = this.getOptions(entity, sortArgs);
            if (sortOptions) {
                const sort = this.sortAndPaginationFactory.createSortFields(sortOptions, entity, context);
                operation.addSort(...sort);
                const pagination = this.sortAndPaginationFactory.createPagination(sortOptions);
                if (pagination) {
                    operation.addPagination(pagination);
                }
            }
        }
        return operation;
    }
    getOptions(entity, options) {
        if (!options) {
            return undefined;
        }
        const limitDirective = (0, is_union_entity_1.isUnionEntity)(entity) ? undefined : entity.annotations.limit;
        let limit = options?.limit ?? limitDirective?.default ?? limitDirective?.max;
        if (limit instanceof neo4j_driver_1.Integer) {
            limit = limit.toNumber();
        }
        const maxLimit = limitDirective?.max;
        if (limit !== undefined && maxLimit !== undefined) {
            limit = Math.min(limit, maxLimit);
        }
        if (limit === undefined && options.offset === undefined && options.sort === undefined)
            return undefined;
        return {
            limit,
            offset: options.offset,
            sort: options.sort,
        };
    }
    getSelectedAttributes(entity, rawFields) {
        return (0, utils_2.filterTruthy)(Object.values(rawFields).map((field) => {
            const { fieldName } = (0, parse_selection_set_fields_1.parseSelectionSetField)(field.name);
            return entity.findAttribute(fieldName);
        }));
    }
    getWhereArgs(resolveTree, reference) {
        const whereArgs = (0, utils_2.isRecord)(resolveTree.args.where) ? resolveTree.args.where : {};
        if (resolveTree.name === "_entities" && reference) {
            const { __typename, ...referenceWhere } = reference;
            return { ...referenceWhere, ...whereArgs };
        }
        return whereArgs;
    }
}
exports.OperationsFactory = OperationsFactory;
//# sourceMappingURL=OperationFactory.js.map